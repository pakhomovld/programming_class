# 5 4 2 6 1 3 9 8
# 4 2 1 3
# 1 2 3 + 4

# 6 9 8
# 6
# 8 9
# 6 + 8 9

# 1 2 3 4
# 6 8 9

# 1 2 3 4 5 6 8 9

def qsort(arr: [int]) -> [int]:
    if not arr:
        return []
    else:
        arr_before = []
        arr_after = []
        first = arr[0]
        for i in range(1, len(arr)):
            if arr[i] < first:
                arr_before.append(arr[i])
            else:
                arr_after.append(arr[i])
        
        return qsort(arr_before) + [first] + qsort(arr_after)


arr = [5, 4, 2, 6, 1, 3, 9, 8]
print(qsort(arr))


# 4 9 1 2 8 6
# 4 9 1
# 2 8 6

# 9

# 1 2 4 6 8 9

# qsort на Go
# сделать сразу на Go 

# Разбиваем массив на два подмассива по середине

# Каждый подмассив рекурсивно сортируем

# склеиваем эти два сортированных подмассива следующим образом:
# рассматриваем на каждом шаге нулевой элемент первого массива и нулевой элемент второго массива
# тот который меньше кладем в новый массив и удаляем его из подмассива откуда взяли
# повторяем это пока один из массивов не станет пустым

# разбит на 2 функции

# 1 берет массив и сортирует его
# 2 берет два массива отсортированных и склеивает их

# первая функция использует внутри вторую

        